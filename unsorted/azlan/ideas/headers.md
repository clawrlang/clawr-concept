# Header Files

Robert “Uncle Bob” Martin has pointed out that modern object-oriented languages have weaker encapsulation than C. In his mind it was C++ that broke encapsulationdd (though at least Objective C has the same problem). C++ requires structures to be declared in the header file, presumably because the `alloc()` function needs to know how much memory each structure needs (`sizeof(type)`). You cannot instantiate an object without knowing how much room its structure occupies. If that's the only reason why most languages opt out of separating declarations from implementation, maybe this is a problem that can be solved with a little ingenuity?

The user of a type should not be the one to allocate its memory. Instead it should be handled by the type itself. The compiler could add an implicit `static alloc()` function that is part of the implementation. (Or it could combine allocation and initialisation in a single function.) This emulates how constructors work in most existing “object-oriented” languages.

The header file declares types and functions that may be used by other modules:

```azlan
// lib.azh (az for Azlan, h for header)

struct 3DPoint {
    x: real
    y: real
    z: real

    static let origin: 3DPoint
}

// This is a pure function. In Haskell-like fashion the compiler might be
// able to replace the function call with the resulting value. And that value
// might even be entered into the machine code (like a C# `const`) for
// additional performance gain.
pure distance(from start: 3DPoint, to end: 3DPoint): real

object Money {
    init(amount: real)
    init(dollars: integer, cents: integer)
    init(dollars: integer)
    init(cents: integer)

    dollars(): integer
    cents(): integer

    add(other: Money): Money
}

role MoneyRepository {
    add(amount: Money)
    withdraw(amount: Money)
    currentBalance(): Money
}

service Type1MoneyRepository: MoneyRepository {
    add(money: Money) // no need to repeat - should it be disallowed?
}
service Type2MoneyRepository: MoneyRepository {}
```

An implementation file contains the definitions and produces the compiled machine-code:

```azlan
// lib.az (az for Azlan)
// This file is not exposed to clients.
// There is no way to couple to the implementation details defined in this file.

let 3DPoint.origin = { x: 0, y: 0, z: 0 }
pure distance(from start: 3DPoint, to end: 3DPoint): real { ... }

object Money {
    val cents: integer
    init(amount: real) { cents = floor(amount * 100) }

    // Can this single initialiser be enough to handle all three overloads?
    init(dollars: integer = 0, cents: integer = 0) { .cents = dollars * 100 + cents }

    dollars() => floor(cents / 100)
    cents() => cents % 100
}

// A secret type that can only be used inside the module implementation
service Type3MoneyRepository: MoneyRepository {}
```

## No Access-level Keywords

Every declaration in the header file is implicitly public. As long as you reference the header file you can access any type, function or variable declared therein.

The definitions in the implementation file are hidden. There might be additional types in this file and all of them are known only to the module. There is however no way to hide implementation details from other types in the same module. Is this a good thing?

## Implicit Header-Implementation Association

In C, the ‘file.c’ implementation file has to `import file.h`. But that could be made implicit in Azlan by associating files with the same name (except the extension) to be paired up.

This can also be used to ensure that all declarations are implemented. All declarations in module.azh have to have implementations in module.az or compilation fails.

## Internal

Maybe support adding a header for internal use (accessible to the deployment unit, whether we call that a package or library) containing functionality (types, methods, functions) that is not exposed by the public header. Maybe name it file.internal.azh?

If there are two header files, the compiler should discover that and ensure consistency between them. It would require all the internal *and* all the public apis to be implemented in the implementation file.

## Maybe not?

Headers are complex and require writing the same code twice.

An autogenerated header “file” can be used to expose the public interface to clients.
