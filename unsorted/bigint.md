Here is an untested implementation of arbitrarily big integers generated by AI.

```c
// file: bigint.c
// Build: gcc -std=c99 -O2 -Wall bigint.c -o bigint
// Single-file bigint implementation (API + demo)

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <inttypes.h>
#include <string.h>
#include <ctype.h>
#include <limits.h>
#include <assert.h>

/* Minimal documentation:
   - BigInt uses little-endian limbs: limbs[0] is least-significant 32 bits.
   - Base = 2^32 per limb. All arithmetic uses uint64_t intermediates.
   - Public functions: bigint_init, bigint_free, bigint_from_i64, bigint_from_string,
     bigint_to_string, bigint_add, bigint_sub, bigint_mul, bigint_cmp.
*/

/*--- Types ---*/
typedef struct {
    uint32_t *limbs;
    size_t len;
    size_t cap;
    int sign; /* +1 or -1; zero is represented with len==0 and sign==+1 */
} BigInt;

/*--- Helpers: allocation & normalization ---*/
static void *xmalloc(size_t n) {
    void *p = malloc(n);
    if (!p) { fprintf(stderr, "Out of memory\n"); exit(1); }
    return p;
}
static void *xrealloc(void *p, size_t n) {
    void *q = realloc(p, n);
    if (!q) { fprintf(stderr, "Out of memory\n"); exit(1); }
    return q;
}

static void bigint_ensure_cap(BigInt *a, size_t mincap) {
    if (a->cap >= mincap) return;
    size_t newcap = a->cap ? a->cap * 2 : 4;
    while (newcap < mincap) newcap *= 2;
    a->limbs = xrealloc(a->limbs, newcap * sizeof(uint32_t));
    a->cap = newcap;
}

static void bigint_normalize(BigInt *a) {
    while (a->len > 0 && a->limbs[a->len - 1] == 0) a->len--;
    if (a->len == 0) a->sign = +1;
}

/*--- Basic lifecycle ---*/
static void bigint_init(BigInt *a) {
    a->limbs = NULL;
    a->len = 0;
    a->cap = 0;
    a->sign = +1;
}

static void bigint_free(BigInt *a) {
    free(a->limbs);
    a->limbs = NULL;
    a->len = a->cap = 0;
    a->sign = +1;
}

static void bigint_copy(BigInt *dst, const BigInt *src) {
    dst->len = src->len;
    dst->sign = src->sign;
    dst->cap = src->len;
    if (dst->cap) {
        dst->limbs = xmalloc(dst->cap * sizeof(uint32_t));
        memcpy(dst->limbs, src->limbs, dst->len * sizeof(uint32_t));
    } else {
        dst->limbs = NULL;
    }
}

/*--- Constructors ---*/
static void bigint_from_i64(BigInt *out, int64_t v) {
    bigint_init(out);
    if (v == 0) return;
    uint64_t uv;
    if (v < 0) { out->sign = -1; uv = (uint64_t)(-v); }
    else { out->sign = +1; uv = (uint64_t)v; }
    bigint_ensure_cap(out, 2);
    out->limbs[0] = (uint32_t)(uv & 0xFFFFFFFFu);
    out->len = 1;
    uint32_t hi = (uint32_t)(uv >> 32);
    if (hi) {
        out->limbs[1] = hi;
        out->len = 2;
    }
}

/* multiply by small (uint32_t) and optionally add small */
static void bigint_mul_small(BigInt *out, const BigInt *a, uint32_t m) {
    bigint_init(out);
    if (m == 0 || a->len == 0) return;
    bigint_ensure_cap(out, a->len + 1);
    uint64_t carry = 0;
    for (size_t i = 0; i < a->len; ++i) {
        uint64_t prod = (uint64_t)a->limbs[i] * m + carry;
        out->limbs[i] = (uint32_t)(prod & 0xFFFFFFFFu);
        carry = prod >> 32;
    }
    out->len = a->len;
    if (carry) { out->limbs[out->len++] = (uint32_t)carry; }
    out->sign = a->sign;
}

/* add small (uint32_t) in-place: out = a + s */
static void bigint_add_small_inplace(BigInt *out, uint32_t s) {
    uint64_t carry = s;
    size_t i = 0;
    while (carry && i < out->len) {
        uint64_t sum = (uint64_t)out->limbs[i] + carry;
        out->limbs[i] = (uint32_t)sum;
        carry = sum >> 32;
        ++i;
    }
    if (carry) {
        bigint_ensure_cap(out, out->len + 1);
        out->limbs[out->len++] = (uint32_t)carry;
    }
}

/* inplace multiply by small and add digit: out = out * m + add */
static void bigint_mul_small_add_inplace(BigInt *out, uint32_t mul, uint32_t add) {
    uint64_t carry = add;
    for (size_t i = 0; i < out->len; ++i) {
        uint64_t prod = (uint64_t)out->limbs[i] * mul + carry;
        out->limbs[i] = (uint32_t)prod;
        carry = prod >> 32;
    }
    if (carry) { bigint_ensure_cap(out, out->len + 1); out->limbs[out->len++] = (uint32_t)carry; }
}

/*--- Compare helpers ---*/
static int bigint_cmp_abs(const BigInt *a, const BigInt *b) {
    if (a->len != b->len) return (a->len < b->len) ? -1 : 1;
    for (size_t i = a->len; i-- > 0;) {
        if (a->limbs[i] != b->limbs[i]) return (a->limbs[i] < b->limbs[i]) ? -1 : 1;
    }
    return 0;
}

static int bigint_cmp(const BigInt *a, const BigInt *b) {
    if (a->len == 0 && b->len == 0) return 0;
    if (a->sign != b->sign) return (a->sign < b->sign) ? -1 : 1;
    int abs_cmp = bigint_cmp_abs(a, b);
    return a->sign == +1 ? abs_cmp : -abs_cmp;
}

/*--- Absolute add/sub (assume dest distinct) ---*/
static void add_abs(BigInt *dest, const BigInt *a, const BigInt *b) {
    size_t n = (a->len > b->len) ? a->len : b->len;
    bigint_init(dest);
    bigint_ensure_cap(dest, n + 1);
    uint64_t carry = 0;
    for (size_t i = 0; i < n; ++i) {
        uint64_t av = (i < a->len) ? a->limbs[i] : 0;
        uint64_t bv = (i < b->len) ? b->limbs[i] : 0;
        uint64_t s = av + bv + carry;
        dest->limbs[i] = (uint32_t)s;
        carry = s >> 32;
    }
    dest->len = n;
    if (carry) dest->limbs[dest->len++] = (uint32_t)carry;
    dest->sign = +1;
    bigint_normalize(dest);
}

/* computes dest = |a| - |b|, assumes |a| >= |b| */
static void sub_abs(BigInt *dest, const BigInt *a, const BigInt *b) {
    bigint_init(dest);
    bigint_ensure_cap(dest, a->len);
    int64_t borrow = 0;
    for (size_t i = 0; i < a->len; ++i) {
        int64_t av = a->limbs[i];
        int64_t bv = (i < b->len) ? b->limbs[i] : 0;
        int64_t r = av - bv - borrow;
        if (r < 0) { r += ((int64_t)1 << 32); borrow = 1; }
        else borrow = 0;
        dest->limbs[i] = (uint32_t)r;
    }
    dest->len = a->len;
    dest->sign = +1;
    bigint_normalize(dest);
}

/*--- Sign-aware add/sub ---*/
static void bigint_add(BigInt *dest, const BigInt *a, const BigInt *b) {
    if (a->len == 0) { bigint_copy(dest, b); return; }
    if (b->len == 0) { bigint_copy(dest, a); return; }
    if (a->sign == b->sign) {
        add_abs(dest, a, b);
        dest->sign = a->sign;
    } else {
        int cmp = bigint_cmp_abs(a, b);
        if (cmp == 0) { bigint_init(dest); return; }
        if (cmp > 0) { sub_abs(dest, a, b); dest->sign = a->sign; }
        else { sub_abs(dest, b, a); dest->sign = b->sign; }
    }
}

/* dest = a - b */
static void bigint_sub(BigInt *dest, const BigInt *a, const BigInt *b) {
    BigInt nb;
    bigint_init(&nb);
    bigint_copy(&nb, b);
    nb.sign = -nb.sign;
    bigint_add(dest, a, &nb);
    bigint_free(&nb);
}

/*--- Multiplication (schoolbook) ---*/
static void bigint_mul(BigInt *dest, const BigInt *a, const BigInt *b) {
    bigint_init(dest);
    if (a->len == 0 || b->len == 0) return;
    size_t n = a->len, m = b->len;
    bigint_ensure_cap(dest, n + m);
    for (size_t i = 0; i < n + m; ++i) dest->limbs[i] = 0;
    for (size_t i = 0; i < n; ++i) {
        uint64_t carry = 0;
        for (size_t j = 0; j < m; ++j) {
            uint64_t cur = (uint64_t)dest->limbs[i + j] + (uint64_t)a->limbs[i] * (uint64_t)b->limbs[j] + carry;
            dest->limbs[i + j] = (uint32_t)cur;
            carry = cur >> 32;
        }
        dest->limbs[i + m] = (uint32_t)carry;
    }
    dest->len = n + m;
    dest->sign = a->sign * b->sign;
    bigint_normalize(dest);
}

/*--- Divide by small uint32_t in-place. Returns remainder. ---*/
/* Divides a by d (1 <= d <= UINT32_MAX) */
static uint32_t bigint_divmod_small(BigInt *a, uint32_t d) {
    if (d == 0) { fprintf(stderr, "Division by zero\n"); exit(1); }
    if (a->len == 0) return 0;
    uint64_t rem = 0;
    for (size_t i = a->len; i-- > 0;) {
        uint64_t cur = (rem << 32) | a->limbs[i];
        a->limbs[i] = (uint32_t)(cur / d);
        rem = cur % d;
    }
    bigint_normalize(a);
    return (uint32_t)rem;
}

/*--- Decimal parsing & printing ---*/
static void bigint_from_string(BigInt *out, const char *s) {
    bigint_init(out);
    while (isspace((unsigned char)*s)) ++s;
    int neg = 0;
    if (*s == '+' || *s == '-') { if (*s == '-') neg = 1; ++s; }
    while (*s == '0') ++s; /* skip leading zeros */
    if (!isdigit((unsigned char)*s)) return; /* zero or invalid -> zero */
    /* We'll accumulate using base 2^32 limbs by doing: x = x*10 + digit */
    BigInt tmp;
    bigint_init(&tmp);
    bigint_ensure_cap(&tmp, 4);
    tmp.len = 0;
    tmp.sign = +1;
    for (; *s && isdigit((unsigned char)*s); ++s) {
        /* tmp = tmp * 10 + digit */
        bigint_mul_small(&tmp, &tmp, 10);
        if (!tmp.cap) { /* multiplication created no limbs for zero; allocate */
            bigint_ensure_cap(&tmp, 1);
        }
        /* add digit */
        if (tmp.len == 0) {
            if (*s != '0') {
                bigint_ensure_cap(&tmp, 1);
                tmp.limbs[0] = (uint32_t)(*s - '0');
                tmp.len = 1;
            }
        } else {
            bigint_add_small_inplace(&tmp, (uint32_t)(*s - '0'));
        }
    }
    bigint_copy(out, &tmp);
    out->sign = (out->len == 0) ? +1 : (neg ? -1 : +1);
    bigint_free(&tmp);
}

/* convert to decimal string; caller must free returned char* */
static char *bigint_to_string(const BigInt *in) {
    if (in->len == 0) {
        char *z = xmalloc(2);
        z[0] = '0'; z[1] = '\0';
        return z;
    }
    /* Copy input because we'll divide by 1e9 repeatedly. */
    BigInt tmp;
    bigint_init(&tmp);
    bigint_copy(&tmp, in);
    tmp.sign = +1; /* abs copy */

    /* collect base 1e9 digits */
    const uint32_t BASE = 1000000000u;
    uint32_t *chunks = NULL;
    size_t nchunks = 0, chunkcap = 0;
    while (tmp.len > 0) {
        uint32_t rem = bigint_divmod_small(&tmp, BASE);
        if (nchunks + 1 > chunkcap) {
            chunkcap = chunkcap ? chunkcap * 2 : 4;
            chunks = xrealloc(chunks, chunkcap * sizeof(uint32_t));
        }
        chunks[nchunks++] = rem;
    }
    /* estimate chars: nchunks*(9 digits) + sign + terminator */
    size_t est = nchunks * 9 + 2;
    char *buf = xmalloc(est);
    char *p = buf;
    if (in->sign < 0) *p++ = '-';
    /* print most significant chunk without leading zeros, others padded to 9 digits */
    int idx = (int)nchunks - 1;
    sprintf(p, "%u", chunks[idx]);
    p += strlen(p);
    for (int i = idx - 1; i >= 0; --i) {
        /* pad to 9 digits */
        sprintf(p, "%09u", chunks[i]);
        p += 9;
    }
    *p = '\0';
    free(chunks);
    bigint_free(&tmp);
    return buf;
}

/*--- Bit shift left by bits (bits < 32) implemented, and by multiple of 32 ---*/
static void bigint_shl_bits(BigInt *dest, const BigInt *a, unsigned bits) {
    if (a->len == 0) { bigint_init(dest); return; }
    unsigned word_shift = bits / 32;
    unsigned bit_shift = bits % 32;
    bigint_init(dest);
    bigint_ensure_cap(dest, a->len + word_shift + 1);
    for (size_t i = 0; i < word_shift; ++i) dest->limbs[i] = 0;
    uint64_t carry = 0;
    for (size_t i = 0; i < a->len; ++i) {
        uint64_t cur = ((uint64_t)a->limbs[i] << bit_shift) | carry;
        dest->limbs[word_shift + i] = (uint32_t)cur;
        carry = cur >> 32;
    }
    size_t out_len = a->len + word_shift;
    if (carry) dest->limbs[out_len++] = (uint32_t)carry;
    dest->len = out_len;
    dest->sign = a->sign;
    bigint_normalize(dest);
}

/*--- Simple tests & demo ---*/
int main(void) {
    /* A few demos to show usage */
    BigInt a, b, c;
    bigint_init(&a); bigint_init(&b); bigint_init(&c);

    /* from int64 */
    bigint_from_i64(&a, 1234567890123456789LL);
    char *s1 = bigint_to_string(&a);
    printf("a = %s\n", s1);
    free(s1);

    /* from decimal string (large) */
    bigint_from_string(&b, "-9876543210987654321098765432109876543210");
    char *s2 = bigint_to_string(&b);
    printf("b = %s\n", s2);
    free(s2);

    /* addition */
    bigint_add(&c, &a, &b);
    char *s3 = bigint_to_string(&c);
    printf("a + b = %s\n", s3);
    free(s3);

    /* multiplication */
    bigint_mul(&c, &a, &b);
    char *s4 = bigint_to_string(&c);
    printf("a * b = %s\n", s4);
    free(s4);

    /* compare */
    int cmp = bigint_cmp(&a, &b);
    printf("cmp(a,b) = %d (a %s b)\n", cmp, (cmp<0?"<":(cmp>0?">":"==")));

    /* shift left */
    bigint_shl_bits(&c, &a, 40); /* multiply by 2^40 */
    char *s5 = bigint_to_string(&c);
    printf("a << 40 = %s\n", s5);
    free(s5);

    /* cleanup */
    bigint_free(&a); bigint_free(&b); bigint_free(&c);

    /* small arithmetic test */
    BigInt x, y, z;
    bigint_from_string(&x, "123456789123456789123456789");
    bigint_from_string(&y, "987654321987654321987654321");
    bigint_mul(&z, &x, &y);
    char *p = bigint_to_string(&z);
    printf("x*y = %s\n", p);
    free(p);
    bigint_free(&x); bigint_free(&y); bigint_free(&z);

    return 0;
}
```
